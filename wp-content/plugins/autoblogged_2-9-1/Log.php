<?php
/**
* The Log:: class implements both an abstraction for various logging
* mechanisms and the Subject end of a Subject-Observer pattern.
*
* @author  Chuck Hagenbuch <chuck@horde.org>
* @author  Jon Parise <jon@php.net>
* @since   Horde 1.3
* @package Log
*/


define('PEAR_LOG_EMERG', 0); define('PEAR_LOG_ALERT', 1); define('PEAR_LOG_CRIT', 2); define('PEAR_LOG_ERR', 3); define('PEAR_LOG_WARNING', 4); define('PEAR_LOG_NOTICE', 5); define('PEAR_LOG_INFO', 6); define('PEAR_LOG_DEBUG', 7); define('PEAR_LOG_ALL', 0xffffffff); define('PEAR_LOG_NONE', 0x00000000); define('PEAR_LOG_TYPE_SYSTEM', 0); define('PEAR_LOG_TYPE_MAIL', 1); define('PEAR_LOG_TYPE_DEBUG', 2); define('PEAR_LOG_TYPE_FILE', 3); define('PEAR_LOG_TYPE_SAPI', 4); class Log { var $_opened = false; var $_id = 0; var $_ident = ''; var $_priority = PEAR_LOG_INFO; var $_mask = PEAR_LOG_ALL; 
var $_listeners = array(); var $_formatMap = array('%{timestamp}' => '%1$s', '%{ident}' => '%2$s', '%{priority}' => '%3$s', '%{message}' => '%4$s', '%{file}' => '%5$s', '%{line}' => '%6$s', '%{function}' => '%7$s', '%{class}' => '%8$s', '%\{' => '%%{'); public static function factory($handler, $name = '', $ident = '', $conf = array(), $level = PEAR_LOG_DEBUG) { $handler = strtolower($handler); $class = 'Log_' . $handler; $classfile = $handler . '.php'; if (!class_exists($class, false)) { include_once $classfile; } if (class_exists($class, false)) { $obj = new $class($name, $ident, $conf, $level); 
return $obj; } $null = null; return $null; } 
public static function singleton($handler, $name = '', $ident = '', $conf = array(), $level = PEAR_LOG_DEBUG) { static $instances; if (!isset($instances)) $instances = array(); $signature = serialize(array($handler, $name, $ident, $conf, $level)); if (!isset($instances[$signature])) { $instances[$signature] = Log::factory($handler, $name, $ident, $conf, $level); } return $instances[$signature]; } function open() { return false; } function close() { return false; } function flush() { return false; } function log($message, $priority = null) { return false; } function emerg($message) { return $this->log($message, PEAR_LOG_EMERG); } function alert($message) { return $this->log($message, PEAR_LOG_ALERT); } function crit($message) { return $this->log($message, PEAR_LOG_CRIT); } 
function err($message) { return $this->log($message, PEAR_LOG_ERR); } function warning($message) { return $this->log($message, PEAR_LOG_WARNING); } function notice($message) { return $this->log($message, PEAR_LOG_NOTICE); } function info($message) { return $this->log($message, PEAR_LOG_INFO); } 
function debug($message) { return $this->log($message, PEAR_LOG_DEBUG); } function _extractMessage($message) { if (is_object($message)) { if (method_exists($message, 'getmessage')) { $message = $message->getMessage(); } else if (method_exists($message, 'tostring')) { $message = $message->toString(); } else if (method_exists($message, '__tostring')) { $message = (string)$message; } else { $message = var_export($message, true); } } else if (is_array($message)) { if (isset($message['message'])) { if (is_scalar($message['message'])) { $message = $message['message']; } else { $message = var_export($message['message'], true); } } else { $message = var_export($message, true); } } else if (is_bool($message) || $message === NULL) { $message = var_export($message, true); } return $message; } function _getBacktraceVars($depth) { $bt = debug_backtrace(); $bt0 = isset($bt[$depth]) ? $bt[$depth] : null; $bt1 = isset($bt[$depth + 1]) ? $bt[$depth + 1] : null; 
$class = isset($bt1['class']) ? $bt1['class'] : null; if ($class !== null && strcasecmp($class, 'Log_composite') == 0) { $depth++; $bt0 = isset($bt[$depth]) ? $bt[$depth] : null; $bt1 = isset($bt[$depth + 1]) ? $bt[$depth + 1] : null; $class = isset($bt1['class']) ? $bt1['class'] : null; } $file = isset($bt0) ? $bt0['file'] : null; $line = isset($bt0) ? $bt0['line'] : 0; $func = isset($bt1) ? $bt1['function'] : null; if (in_array($func, array('emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug'))) { $bt2 = isset($bt[$depth + 2]) ? $bt[$depth + 2] : null; $file = is_array($bt1) ? 
$bt1['file'] : null; $line = is_array($bt1) ? $bt1['line'] : 0; $func = is_array($bt2) ? $bt2['function'] : null; $class = isset($bt2['class']) ? $bt2['class'] : null; } if ($func === null) { $func = '(none)'; } return array($file, $line, $func, $class); } function _format($format, $timestamp, $priority, $message) { if (preg_match('/%[5678]/', $format)) { list($file, $line, $func, $class) = $this->_getBacktraceVars(2); } 
return sprintf($format, $timestamp, $this->_ident, $this->priorityToString($priority), $message, isset($file) ? $file : '', isset($line) ? $line : '', isset($func) ? $func : '', isset($class) ? $class : ''); } function priorityToString($priority) { $levels = array( PEAR_LOG_EMERG => 'emergency', PEAR_LOG_ALERT => 'alert', PEAR_LOG_CRIT => 'critical', PEAR_LOG_ERR => 'error', PEAR_LOG_WARNING => 'warning', PEAR_LOG_NOTICE => 'notice', PEAR_LOG_INFO => 'info', PEAR_LOG_DEBUG => 'debug' ); return $levels[$priority]; } 
function stringToPriority($name) { $levels = array( 'emergency' => PEAR_LOG_EMERG, 'alert' => PEAR_LOG_ALERT, 'critical' => PEAR_LOG_CRIT, 'error' => PEAR_LOG_ERR, 'warning' => PEAR_LOG_WARNING, 'notice' => PEAR_LOG_NOTICE, 'info' => PEAR_LOG_INFO, 'debug' => PEAR_LOG_DEBUG ); return $levels[strtolower($name)]; } public static function MASK($priority) { return (1 << $priority); } public static function UPTO($priority) { return Log::MAX($priority); } public static function MIN($priority) { return PEAR_LOG_ALL ^ ((1 << $priority) - 1); } 
public static function MAX($priority) { return ((1 << ($priority + 1)) - 1); } function setMask($mask) { $this->_mask = $mask; return $this->_mask; } function getMask() { return $this->_mask; } function _isMasked($priority) { return (Log::MASK($priority) & $this->_mask); } function getPriority() { return $this->_priority; } 
function setPriority($priority) { $this->_priority = $priority; } function attach(&$observer) { if (!is_a($observer, 'Log_observer')) { return false; } $this->_listeners[$observer->_id] = &$observer; return true; } function detach($observer) { if (!is_a($observer, 'Log_observer') || !isset($this->_listeners[$observer->_id])) { return false; } unset($this->_listeners[$observer->_id]); return true; } 
function _announce($event) { foreach ($this->_listeners as $id => $listener) { if ($event['priority'] <= $this->_listeners[$id]->_priority) { $this->_listeners[$id]->notify($event); } } } function isComposite() { return false; } function setIdent($ident) { $this->_ident = $ident; } function getIdent() { return $this->_ident; } }
